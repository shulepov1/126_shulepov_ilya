public class Task_1 implements Task_1_base {
    @Override
    public int subtask_1_if(int first, int second, int third) {
        // Вычислить и вернуть минимальный из трех полученных аргументов (first, second, third)
        // ------------------------------------------------------------------------------------
        if ((first < second) & (first < third)) {
            return first;
        }
        if ((second < first) & (second < third)) {
            return second;
        } else return third;
        // Замените данный оператор кодом, решающим поставленную задачу.
    }

    @Override
    public boolean subtask_2_if(int year) {
        // Проверить, является ли год, переданный в параметре year, високосным.
        // Високосный год - это год, кратный четырем, но не кратный 100, либо кратный 400
        // Замените данный оператор кодом, решающим поставленную задачу.
       return year % 4 == 0 && (year % 100 != 0 || (year % 100 == 0 && year % 400 == 0));
    }

    @Override
    public int subtask_3_if(double x, double y, double left_up_x, double left_up_y, double width, double height) {
        // Проверить, лежит ли точка с координатами (x, y) внутри невырожденного квадрата
        // со сторонами, параллельными осям координат, левый верхний угол которого имеет
        // координаты (left_up_x, left_up_y), ширина которого width, высота height.
        // Точка на границе считается не лежащей внутри.
        // В качестве результата вернуть:
        // 0 - не лежит
        // 1 - лежит
        // 2 - аргументы функции заданы некорректно
        // Допустимой погрешностью при сравнении переменных типа double считать 0.000001
        if (Math.abs(width - height) < .000001) {
            if (Math.abs(x - left_up_x) < .000001 && Math.abs(x - (left_up_x + width)) < .000001 && Math.abs(left_up_y - y) < .000001 && Math.abs(y - left_up_y + height) < .000001) {
                return 0;
            }
            if (x > left_up_x && x < (left_up_x + width) && y < left_up_y && y > (left_up_y - height)) {
                return 1;
            }
        }
            else
            {
                return 2;
            }

        return 0;
    }


        //if (((x > left_up_x) & (x < (left_up_x + width))) & ((y < left_up_y) & (y > (left_up_y - height)))) {
        //    return 1;
        //}
        //if ((Math.abs(width - height)) > .000001) {
        //    return 2;
       // } else return 0;
        // Замените данный оператор кодом, решающим поставленную задачу.}

    @Override
    public int subtask_4_if(double x0, double y0, double k, double b) {
        // Проверить, как расположена точка с координатами (x0, y0)
        // относительно прямой y = kx + b
        // В качестве результата вернуть:
        // 0 - лежит выше прямой
        // 1 - лежит ниже прямой
        // 2 - лежит на прямой
        // Допустимой погрешностью при сравнении переменных типа double считать 0.000001
        if (Math.abs(y0 - (k*x0 + b)) < .000001) {
            return 2;
        }
        else {
                if(k*x0 + b < y0) {
                    return 0;
                }
                else {
                    return 1;
                }
            }
        // ------------------------------------------------------------------------------------
        // Замените данный оператор кодом, решающим поставленную задачу.
    }

    @Override
    public String subtask_5_switch(int day_of_week) {
        // По номеру дня недели day_of_week вернуть его название на русском языке, записанное
        // с большой буквы. Дни недели отсчитываются с единицы. Если номер задан некорректно,
        // вернуть строку "Ошибка"
        String result = switch (day_of_week) {
            case 1 -> "Понедельник";
            case 2 -> "Вторник";
            case 3 -> "Среда";
            case 4 -> "Четверг";
            case 5 -> "Пятница";
            case 6 -> "Суббота";
            case 7 -> "Воскресенье";
            default -> "Ошибка";
            // ------------------------------------------------------------------------------------
            // Замените данный оператор кодом, решающим поставленную задачу.
        };
        return result;
    }


        @Override
        public String subtask_6_switch ( int direction){
            // По заданному направлению direction вернуть его название:
            // 1 - север
            // 2 - юг
            // 3 - запад
            // 4 - восток
            // Во всех остальных случаях вернуть пустую строку
            // ------------------------------------------------------------------------------------
            return switch (direction) {
                case 1 -> "север";
                case 2 -> "юг";
                case 3 -> "запад";
                case 4 -> "восток";
                default -> "";
            }; // Замените данный оператор кодом, решающим поставленную задачу.
        }


        @Override
        public int subtask_7_if ( double vx, double vy, double vz, double speed, double time, double wall){
            // Проверить, достигнет ли снаряд, летяший из точки (0, 0, 0)
            // в направлении (vx, vy, vz) со скоростью speed стены, параллельной плоскости OYZ,
            // имеющей координату x равной wall, за время time
            // 0 - не достигнет
            // 1 - достигнет
            // 2 - аргументы функции заданы некорректно
            // Допустимой погрешностью при сравнении переменных типа double считать 0.000001
            // ------------------------------------------------------------------------------------
            if(time>0.000001 && speed>0.000001){
                double V = (Math.sqrt(wall * wall + vy * wall / vx * vy * wall / vx + vz * wall / vx * vz * wall / vx)) / speed;
                if (V <= time) {
                    return 1;
                }
                if (Math.abs(V - time) < 0.000001) {
                    return 1;
                }
                else {
                    return 0;
                }
            }
            else{
                return 2;
            } // Замените данный оператор кодом, решающим поставленную задачу.
        }


        @Override
        public int subtask_8_if ( double k1, double b1, double k2, double b2){
            // Проверить, как друг относительно друга располагаются прямые y = k1*x + b1 и
            // y = k2*x + b2. Вернуть
            // 1 - если параллельны
            // 2 - если пересекаются
            // 3 - если совпадают
            // Допустимой погрешностью при сравнении переменных типа double считать 0.000001
            if (Math.abs(k1 - k2) < .000001 && Math.abs(b1 - b2) > .000001) {
                return 1;
            }
            if (Math.abs(k1 - k2) < .000001 && Math.abs(b1 - b2) < .000001) {
                return 3;
            }
            else {
                return 2;
            }

        }
            // ------------------------------------------------------------------------------------
            // Замените данный оператор кодом, решающим поставленную задачу.


}
